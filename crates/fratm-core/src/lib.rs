//! # FratmScript Core
//!
//! **FratmScript** is a transpiler that converts code written in Neapolitan dialect
//! into executable JavaScript. This is the core of the FratmScript project.
//!
//! ## Overview
//!
//! The compiler follows the classic three-phase architecture:
//!
//! 1. **Lexer** ([`lexer`]): Lexical analysis - converts source code into tokens
//! 2. **Parser** ([`parser`]): Syntax analysis - builds the Abstract Syntax Tree (AST)
//! 3. **CodeGen** ([`codegen`]): Code generation - produces JavaScript from the AST
//!
//! ## Basic Example
//!
//! ```rust
//! use fratm_core::compile;
//!
//! let source = r#"
//!     chist è nome = "Gennaro"
//!     stamm a dì(nome)
//! "#;
//!
//! let result = compile(source, Default::default()).unwrap();
//! println!("{}", result.code);
//! // Output: const nome = "Gennaro";
//! //         console.log(nome);
//! ```
//!
//! ## FratmScript Syntax
//!
//! | Construct | FratmScript | JavaScript |
//! |-----------|-------------|------------|
//! | Constant | `chist è x = 1` | `const x = 1` |
//! | Variable | `tien x = 1` | `let x = 1` |
//! | Function | `facc nome() {}` | `function nome() {}` |
//! | Return | `piglie value` | `return value` |
//! | If/Else | `si (cond) {} sinnò {}` | `if (cond) {} else {}` |
//! | For loop | `pe (init; cond; upd) {}` | `for (init; cond; upd) {}` |
//! | While | `mentre che (cond) {}` | `while (cond) {}` |
//! | Console | `stamm a dì(x)` | `console.log(x)` |
//! | Class | `na famiglie Nome {}` | `class Nome {}` |
//! | New | `nu bell Nome()` | `new Nome()` |
//! | This | `stu cos` | `this` |
//! | True/False | `overo` / `sfòls` | `true` / `false` |
//! | Null | `nisciun` | `null` |
//! | Undefined | `boh` | `undefined` |
//!
//! ## Source Maps
//!
//! The compiler supports v3 source map generation for debugging:
//!
//! ```rust
//! use fratm_core::{compile, CompileOptions};
//!
//! let options = CompileOptions {
//!     source_map: true,
//!     filename: Some("main.fratm".to_string()),
//!     ..Default::default()
//! };
//!
//! let result = compile("chist è x = 42", options).unwrap();
//! if let Some(map) = result.source_map {
//!     println!("{}", map.to_json());
//! }
//! ```
//!
//! ## Error Handling
//!
//! Errors are localized in Neapolitan for an authentic experience:
//!
//! ```rust
//! use fratm_core::compile;
//!
//! let result = compile("chist nome = 1", Default::default()); // Missing "è"
//! assert!(result.is_err());
//! // Error: "Doppo 'chist' ce vo' 'è'! Scrivi 'chist è' pe fà 'na costante."
//! ```

pub mod lexer;
pub mod parser;
pub mod codegen;
pub mod errors;
pub mod sourcemap;

use errors::CompileError;
use lexer::Lexer;
use parser::Parser;
use codegen::CodeGen;
use sourcemap::SourceMap;

/// Compilation options to customize the transpiler behavior.
///
/// # Example
///
/// ```rust
/// use fratm_core::CompileOptions;
///
/// let options = CompileOptions {
///     source_map: true,
///     filename: Some("main.fratm".to_string()),
///     minify: false,
/// };
/// ```
#[derive(Debug, Clone, Default)]
pub struct CompileOptions {
    /// Generate source maps for debugging.
    ///
    /// When enabled, the compilation result will include a source map
    /// that maps the generated JavaScript to the original FratmScript code.
    pub source_map: bool,

    /// Source filename (used for source maps and error messages).
    ///
    /// If not specified, "input.fratm" is used as default.
    pub filename: Option<String>,

    /// Minify the JavaScript output (not yet implemented).
    ///
    /// When enabled, removes whitespace and shortens variable names.
    pub minify: bool,
}

/// Compilation result containing the generated code and metadata.
///
/// # Fields
///
/// * `code` - The generated JavaScript code
/// * `source_map` - Optional source map (if requested in options)
/// * `warnings` - List of non-fatal warnings generated during compilation
///
/// # Example
///
/// ```rust
/// use fratm_core::compile;
///
/// let result = compile("stamm a dì(42)", Default::default()).unwrap();
/// assert!(result.code.contains("console.log(42)"));
/// assert!(result.warnings.is_empty());
/// ```
#[derive(Debug, Clone)]
pub struct CompileResult {
    /// JavaScript code generated by the transpiler.
    pub code: String,

    /// Optional source map (present only if `source_map: true` in options).
    pub source_map: Option<SourceMap>,

    /// Non-fatal warnings generated during compilation.
    ///
    /// These are issues that don't prevent compilation but may
    /// indicate logical errors in the code.
    pub warnings: Vec<String>,
}

/// Compiles FratmScript code to JavaScript.
///
/// This is the main transpiler function. It takes source code
/// in Neapolitan syntax and produces equivalent JavaScript.
///
/// # Arguments
///
/// * `source` - The FratmScript source code to compile
/// * `options` - Compilation options (source maps, minification, etc.)
///
/// # Returns
///
/// * `Ok(CompileResult)` - Successful compilation with JS code
/// * `Err(CompileError)` - Compilation error with localized message
///
/// # Errors
///
/// This function can fail due to:
/// * Lexical errors (unclosed strings, invalid characters)
/// * Syntax errors (missing parentheses, wrong keywords)
///
/// # Example
///
/// ```rust
/// use fratm_core::{compile, CompileOptions};
///
/// // Simple compilation
/// let result = compile("chist è x = 42", Default::default()).unwrap();
/// assert!(result.code.contains("const x = 42"));
///
/// // With source map
/// let options = CompileOptions { source_map: true, ..Default::default() };
/// let result = compile("chist è x = 42", options).unwrap();
/// assert!(result.source_map.is_some());
/// ```
///
/// # Compilation Pipeline
///
/// ```text
/// Source Code → Lexer → Tokens → Parser → AST → CodeGen → JavaScript
/// ```
pub fn compile(source: &str, options: CompileOptions) -> Result<CompileResult, CompileError> {
    // Lexing
    let mut lexer = Lexer::new(source);
    let tokens = lexer.tokenize();

    // Check for lexer errors
    let lex_errors: Vec<_> = tokens.iter()
        .filter_map(|t| {
            if let lexer::TokenKind::Invalid(msg) = &t.kind {
                Some(CompileError::LexerError {
                    message: msg.clone(),
                    line: t.span.line,
                    column: t.span.column,
                })
            } else {
                None
            }
        })
        .collect();

    if !lex_errors.is_empty() {
        return Err(lex_errors.into_iter().next().unwrap());
    }

    // Parsing
    let mut parser = Parser::new(tokens);
    let program = parser.parse().map_err(|errors| {
        let first = errors.into_iter().next().unwrap();
        CompileError::ParseError {
            message: first.message,
            line: first.span.line,
            column: first.span.column,
        }
    })?;

    // Code generation
    let mut codegen = CodeGen::new(options.source_map);
    let code = codegen.generate(&program);

    let source_map = if options.source_map {
        Some(codegen.get_source_map())
    } else {
        None
    };

    Ok(CompileResult {
        code,
        source_map,
        warnings: vec![],
    })
}

/// Returns the current FratmScript version.
///
/// # Example
///
/// ```rust
/// use fratm_core::version;
///
/// println!("FratmScript v{}", version());
/// ```
pub fn version() -> &'static str {
    env!("CARGO_PKG_VERSION")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_compile() {
        let result = compile("chist è x = 42", Default::default()).unwrap();
        assert!(result.code.contains("const x = 42"));
    }

    #[test]
    fn test_function_compile() {
        let result = compile("facc test() { piglie 1 }", Default::default()).unwrap();
        assert!(result.code.contains("function test()"));
        assert!(result.code.contains("return 1"));
    }
}
